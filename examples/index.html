<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>canvas-polyline browser test</title>
  <style>
    .wrapper {
      display: grid;
      grid-gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }

    .box {
      padding: 16px;
    }

    canvas {
      background: #fff;
      box-shadow: 2px 2px 5px #ccc;
    }
  </style>
</head>

<body>
  <h1>canvas-polyline browser test</h1>

  <p>
    To facilitate seeing any difference between HTML5 Canvas, D3-Path and
    canvas-polyline
  </p>

  <div class="wrapper">
    <div class="box">
      <h2>canvas (plain JavaScript)</h2>
      <canvas id="canvas-js"></canvas>
    </div>
    <div class="box">
      <h2>canvas-polyline</h2>
      <canvas id="canvas-poly"></canvas>
    </div>
  </div>

  <h2>HPGL</h2>
  <textarea id="hpgl-out" cols="60" rows="12"></textarea>

  <script src="../dist/canvas-polyline.min.js"></script>
  <script>
    const tau = Math.PI * 2;

    const width = 400;
    const height = 400;
    const dpr = window.devicePixelRatio || 1;

    const canvasJS = document.getElementById("canvas-js");
    const canvasPoly = document.getElementById("canvas-poly");

    const canvases = [canvasJS, canvasPoly];

    canvases.forEach((canvas) => {
      canvas.setAttribute("width", width * dpr);
      canvas.setAttribute("height", height * dpr);
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
    });

    const contexts = canvases.map((d) => d.getContext("2d"));

    contexts.forEach((ctx) => {
      ctx.scale(dpr, dpr);
    });

    render(contexts[0]);
    contexts[0].stroke();

    const ctxPoly = new CanvasPolyline();

    console.log({ CanvasPolyline })

    render(ctxPoly);
    const lines = ctxPoly.polylines();
    console.log(lines);
    lines.forEach((line) => {
      contexts[1].moveTo(line[0][0], line[0][1]);
      line.slice(1).forEach((point) => {
        contexts[1].lineTo(point[0], point[1]);
      });
    });
    contexts[1].stroke();

    document.getElementById("hpgl-out")
      .textContent = CanvasPolyline.toHPGL(lines).join(";\n")

    function render(ctx) {
      ctx.rect(0, 0, 100, 10);

      return
      ctx.rect(5, 5, 100, 10);
      ctx.moveTo(160, 30);
      ctx.arc(140, 30, 20, 0, tau);
      ctx.arc(170, 30, 20, 0, tau);
      ctx.quadraticCurveTo(5, 60, 200, 100);
      ctx.bezierCurveTo(50, 50, 100, 20, 200, 100);
      ctx.arcTo(5, 100, 5, 20, 30);
      ctx.lineTo(5, 15);
      drawHeart(ctx, 50, 20, 50, 50);
      drawDiamond(ctx, 80, 50, 30, 40);

      ctx.translate(0, 110);
      ctx.transform(1, 0.2, 0.2, 0.6, 0, 0);

      ctx.rect(5, 5, 100, 10);
      ctx.moveTo(160, 30);
      ctx.arc(140, 30, 20, 0, tau);
      ctx.arc(170, 30, 20, 0, tau);
      ctx.quadraticCurveTo(5, 60, 200, 100);
      ctx.bezierCurveTo(50, 50, 100, 20, 200, 100);
      ctx.arcTo(5, 100, 5, 20, 30);
      ctx.lineTo(5, 15);
      drawHeart(ctx, 50, 20, 50, 50);
      drawDiamond(ctx, 80, 50, 30, 40);
    }

    function drawHeart(ctx, x, y, width, height) {
      console.log("drawHeart", x, y, width, height);
      ctx.save();
      // ctx.beginPath();
      var topCurveHeight = height * 0.3;
      ctx.moveTo(x, y + topCurveHeight);
      // top left curve
      ctx.bezierCurveTo(
        x,
        y,
        x - width / 2,
        y,
        x - width / 2,
        y + topCurveHeight
      );

      // bottom left curve
      ctx.bezierCurveTo(
        x - width / 2,
        y + (height + topCurveHeight) / 2,
        x,
        y + (height + topCurveHeight) / 2,
        x,
        y + height
      );

      // bottom right curve
      ctx.bezierCurveTo(
        x,
        y + (height + topCurveHeight) / 2,
        x + width / 2,
        y + (height + topCurveHeight) / 2,
        x + width / 2,
        y + topCurveHeight
      );

      // top right curve
      ctx.bezierCurveTo(x + width / 2, y, x, y, x, y + topCurveHeight);

      ctx.closePath();
      ctx.restore();
    }

    function drawDiamond(ctx, x, y, width, height) {
      ctx.save();
      // ctx.beginPath();
      ctx.moveTo(x, y);

      // top left edge
      ctx.lineTo(x - width / 2, y + height / 2);

      // bottom left edge
      ctx.lineTo(x, y + height);

      // bottom right edge
      ctx.lineTo(x + width / 2, y + height / 2);

      // closing the path automatically creates
      // the top right edge
      ctx.closePath();
      ctx.restore();
    }
  </script>
</body>

</html>